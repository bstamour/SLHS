\documentclass[a4paper]{report}

\usepackage{fancyvrb}
\DefineVerbatimEnvironment{code}{Verbatim}{fontsize=\small}
\DefineVerbatimEnvironment{example}{Verbatim}{fontsize=\small}
\newcommand{\ignore}[1]{}




\title{A Denotational Semantics for Subjective Logic}
\author{Bryan St. Amour}

\begin{document}

\maketitle


\tableofcontents



%===============================================================================================================



\chapter{Introduction}
\label{chap:introduction}

\section{The Problem Addressed}

Subjective Logic is a fairly recent addition to the family of probablistic logics. As such, though it
is theoretically very interesting, there is a noticable lack of tools that support experimenting with
subjective opinions and their respective operators. In particular, there does not appear to be any
tool that can systematically discern correct subjective expressions from absurd ones. In order to
construct such a tool, one must be able to compute the \emph{meaning} of arbitrary subjective
expressions, and thus accept statements that are well-defined, and reject all others.

Such a tool will allow for users (software engineers, logicians) to explore, construct, and evaluate
subjective expressions, all the while knowing that the expressions that are allowed by the tool are
indeed valid expressions within Subjective Logic. As we shall discuss in later chapters, there are
several cases in which the owner of a particular opinion, the universe in which an opinion is defined,
etc are crucial in determining whether the opinion can be meaningfully combined with opinions from
different owners, different universes, etc. A system that does not filter expressions based on these
and other criteria is a potential bag of scorpions waiting to be opened.



\section{Previous Work on This Problem}

Not a fucking thing. % Make this sound a bit more pleasing.


\section{Our Proposed Solution}

The solution we propose is to construct a denotational semantics to accompany subjective logic.
Effectively we propose to map subjective expressions to terms of a typed lambda calculus, and thus
compute the meaning of expressions through the simple act of sub-expression composition. Once such
a semantic has been constructed, we propose to develop a framework in the \emph{Haskell} programming
language as a proof of concept.


\section{Organization of this Document}

The organization of this thesis is as follows. In chapter \ref{chap:background-information}
we will discuss the relevant background
information required for the full understanding of this thesis. Topics discussed are Subjective Logic,
Formal Semantics of programming languages, and both untyped and typed lambda calculus.
Chapter \ref{chap:denotational-semantics} will
detail the construction of a syntax and denotational semantics of Subjective Logic. In
chapter \ref{chap:sl-framework} we
will describe the system, constructed in the \emph{Haskell} programming language, that stands as a
proof of concept for the denotational semantics described in chapter 3. Finally, concluding remarks
are contained within chapter \ref{chap:conclusion}.


%===============================================================================================================



\chapter{Background Information}
\label{chap:background-information}

\section{Subjective Logic}

\subsection{Overview}

\subsection{Binomial Opinions}

\subsection{Multinomial Opinions}

\subsection{Hyper Opinions}




\section{Formal Semantics}

\subsection{Overview}

\subsection{Operational Semantics}

\subsection{Axiomatic Semantics}

\subsection{Denotational Semantics}

\subsection{Others}




\section{Lambda Calculus}

\subsection{Untyped Lambda Calculus}

\subsection{Simply Typed Lambda Calculus}

\subsection{The Lambda Cube}



%===============================================================================================================



\chapter{Denotational Semantics for Subjective Logic}
\label{chap:denotational-semantics}

\section{Introduction}

\section{A Syntax for Subjective Logic}

\section{A Semantics for Subjective Logic}

\subsection{Untyped Lambda Calculus}      % The basics. No types, just lambda-terms.

\subsection{Simply Typed Lambda Calculus} % Simple types: opinions.

\subsection{Structural Polymorphism}      % Add support for different mass types e.g.

\subsection{Dependent Types}             % For belief holders?




%===============================================================================================================


\chapter{The Subjective Logic Framework}
\label{chap:sl-framework}

\section{Overview}

\par
In this chapter we will describe in detail the Subjective Logic framework
that we have constructed. We chose to implement our framework using the Haskell
programming language. Haskell is a purely-functional programming language, which
means that functions are first-class citizens, and functions are also referentially
transparent: calling the same function multiple times with the same arguments
is guaranteed to return the same result. Haskell by default also employs non-strict
semantics, meaning it will not compute values until they are absolutely required.
While this increases the difficulty of analyzing the complexity of programs, the
benefits of laziness are manyfold.

\par
Our framework has been designed to be modular: the core reasoning system has been
separated from the actual logic implementation. This allows us to extend the framework
beyond simply implementing Subjective Logic and it's operators. Any logical system
can be augmented to the system provided the logical system supports a bare-minimum
set of required operations.



\section{Core Foundations}

\subsection{The Reasoner data type}

\par
The reasoner data type is the core type of our framework. It is a polymorphic data
type defined as

\begin{code}
  data Reasoner logic holders atoms a = Reasoner {
    unR :: MassAssignment holders atoms -> a
  }
\end{code}

where \emph{logic} is a type variable representing the kind of logical system to
use (for example, Subjective Logic), \emph{holders} is a type variable representing
the set of possible belief holders, \emph{atoms} represents the finite set of possible
independent events (the frame of discernment), and lastly \emph{a} is a type variable
representing the result of some computation that the reasoner is tasked with carrying
out.

\par
The auxilliary type \emph{MassAssignment} represents a belief mass assignment. Here
we utilize a Haskell \emph{Map}, which is an associated structure from keys to values.

\begin{code}
import qualified Data.Map as M
data MassAssignment holders atoms = M.Map holders (M.Map [atoms] Rational)
\end{code}

Each belief holder is assigned a belief mass assignment, and a belief mass assignment
is simply a map from arbitrary elements of the reduced powerset of the frame of discernment
onto the rational numbers.

\par
We next define \emph{Functor}, \emph{Monad}, and \emph{Applicative} instances for
Reasoner.

\begin{code}
  instance Functor (Reasoner logic holders atoms) where
    fmap f r = Reasoner $ \mass -> f (unR r mass)

  instance Monad (Reasoner logic holders atoms) where
    return x = Reasoner $ \_ -> x

    ma >>= f = Reasoner $ \mass -> let a  = unR ma mass
                                       mb = f a
                                   in unR mb mass

  instance Applicative (Reasoner logic holders atoms) where
    pure = return
    (<*>) = ap
\end{code}

\par
In short, given an underlying logic system, a set of belief holders, and a set of
atomic events, the Reasoner data type creates a custom Functor, Monad, and Applicative.
This allows us the construct programs for evaluating logical expressions while giving no
consideration to the underlying details of how the expression is implemented. In order
to evaluate such expressions we provide a helper function

\begin{code}
  runReasoner :: Reasoner logic holders atoms a
              -> MassAssignment holders atoms
              -> a
  runReasoner r mass = unR r mass
\end{code}





\subsection{The Logic type class}



\section{The Subjective Logic Implementation}

\subsection{Overview}

\subsection{Operators Implemented}




%===============================================================================================================




\chapter{Conclusion}
\label{chap:conclusion}






%===============================================================================================================


\end{document}
