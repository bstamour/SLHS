\documentclass[a4paper]{report}

\usepackage{fancyvrb}
\DefineVerbatimEnvironment{code}{Verbatim}{fontsize=\small}
\DefineVerbatimEnvironment{example}{Verbatim}{fontsize=\small}
\newcommand{\ignore}[1]{}




\title{A Purely-functional Applicative Subjective Logic Framework}
\author{Bryan St. Amour}

\begin{document}

\maketitle


\tableofcontents


\chapter{Introduction}

\section{The Problem Addressed}

\section{Our Proposed Solution}

\section{Organization of this Document}





\chapter{Background Information}

\section{Subjective Logic}

\subsection{Overview}

\subsection{Binomial Opinions}

\subsection{Multinomial Opinions}

\subsection{Hyper Opinions}






\section{Basic Category Theory}

\subsection{Overview}

\subsection{Categories}

\subsection{Functors}

\subsection{Monads}

\subsection{Applicative Functors}

\subsection{Connections to Programming}








\chapter{The Subjective Logic Framework}

\section{Overview}

\par
In this chapter we will describe in detail the Subjective Logic framework
that we have constructed. We chose to implement our framework using the Haskell
programming language. Haskell is a purely-functional programming language, which
means that functions are first-class citizens, and functions are also referentially
transparent: calling the same function multiple times with the same arguments
is guaranteed to return the same result. Haskell by default also employs non-strict
semantics, meaning it will not compute values until they are absolutely required.
While this increases the difficulty of analyzing the complexity of programs, the
benefits of laziness are manyfold.

\par
Our framework has been designed to be modular: the core reasoning system has been
separated from the actual logic implementation. This allows us to extend the framework
beyond simply implementing Subjective Logic and it's operators. Any logical system
can be augmented to the system provided the logical system supports a bare-minimum
set of required operations.



\section{Core Foundations}

\subsection{The Reasoner data type}

\par
The reasoner data type is the core type of our framework. It is a polymorphic data
type defined as

\begin{code}
  data Reasoner logic holders atoms a = Reasoner {
    unR :: MassAssignment holders atoms -> a
  }
\end{code}

where \emph{logic} is a type variable representing the kind of logical system to
use (for example, Subjective Logic), \emph{holders} is a type variable representing
the set of possible belief holders, \emph{atoms} represents the finite set of possible
independent events (the frame of discernment), and lastly \emph{a} is a type variable
representing the result of some computation that the reasoner is tasked with carrying
out.

\par
The auxilliary type \emph{MassAssignment} represents a belief mass assignment. Here
we utilize a Haskell \emph{Map}, which is an associated structure from keys to values.

\begin{code}
import qualified Data.Map as M
data MassAssignment holders atoms = M.Map holders (M.Map [atoms] Rational)
\end{code}

Each belief holder is assigned a belief mass assignment, and a belief mass assignment
is simply a map from arbitrary elements of the reduced powerset of the frame of discernment
onto the rational numbers.

\par
We next define \emph{Functor}, \emph{Monad}, and \emph{Applicative} instances for
Reasoner.

\begin{code}
  instance Functor (Reasoner logic holders atoms) where
    fmap f r = Reasoner $ \mass -> f (unR r mass)

  instance Monad (Reasoner logic holders atoms) where
    return x = Reasoner $ \_ -> x

    ma >>= f = Reasoner $ \mass -> let a  = unR ma mass
                                       mb = f a
                                   in unR mb mass

  instance Applicative (Reasoner logic holders atoms) where
    pure = return
    (<*>) = ap
\end{code}

\par
In short, given an underlying logic system, a set of belief holders, and a set of
atomic events, the Reasoner data type creates a custom Functor, Monad, and Applicative.
This allows us the construct programs for evaluating logical expressions while giving no
consideration to the underlying details of how the expression is implemented. In order
to evaluate such expressions we provide a helper function

\begin{code}
  runReasoner :: Reasoner logic holders atoms a
              -> MassAssignment holders atoms
              -> a
  runReasoner r mass = unR r mass
\end{code}





\subsection{The Logic type class}



\section{The Subjective Logic Implementation}

\subsection{Overview}

\subsection{Operators Implemented}









\end{document}
