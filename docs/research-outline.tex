\documentclass[a4paper]{article}

% Possible title: Constructing uncertain reasoning systems using applicative functors

% Problem addresssed: stays the same.

% Previous work: stays the same.

% Our idea: implement the set of SL operators on top of a framework constructed from
% applicative functors.

% Justification for the approach:
%  1. Applicative functors are more general than monads, more powerful than functors.
%  2. Allow for cleaner composition: we can construct more probablistic logics than simply SL.
%     and merge/work with them all without breaking a sweat.
%  3. Applicative functors are becomming popular in the pure functional world for controlling
%     computation when the full power of monads is not required.

% Verification of our work:
%  1. Prove the required applicative functor laws of our types.
%  2. Prove termination of our operators.
%  3. Perform complexity analysis of our operators.

% Expected outcomes:
%  1. A new embeddable library for uncertain reasoning that can be utilized via familiar
%     applicative functor syntax.
%  2. Room for extending the library to support more than SL (think DS theory, fuzzy logic, etc.)

% Future work:
%  1. Hope to see our library be put to use in the near future. Talk about the SL+concepts project,
%     the SL web workbench, USMS, etc.

\title{A modular framework for aiding in the construction of uncertain reasoning systems}
\author{Bryan St. Amour}

\begin{document}

\maketitle

\section{The problem addressed}

\par
The main problem that we wish to address is that aside from the Java demos provided
by Josang, there does not appear to be any off-the-shelf framework for experimenting
with, and embedding subjective logic into applications. Software that requires a form
of artifical reasoning and wish to utilize subjective logic appear to be doomed to
rewrite the core operators by hand, which can lead to buggy, slow software.

\section{previous work on the problem}

\par
At the time of this writing, we are unaware of any other frameworks that have been
developed for users wishing to leverage the power of Subjective Logic. However we
are continuing to search for similar work.

\section{Our approach}

\par
We propose to develop a framework for subjective logic that

\begin{itemize}
	\item Can be utilized as a standalone workbench, much like a Read-eval-print loop such as various lisps.
	\item Can be embedded into larger applications which require artificial reasoning.
	\item Is easily extendable to support more kinds of probablistic logics (e.g. Dempster-shafer theory).
	\item Is efficient.
\end{itemize}

\par
We address the above items in the proceeding sections.
Our language of implementation is to be the pure functional programming language Haskell, as it's purity
and non-strict semantics offer various advantages over contemporary imperative languages.

\subsection{A Standalone Workbench}

\par
We plan to leverage the GHC compiler's read-eval-print loop (REPL) in order to create an easy-to-use environment
for which users can model and explore situations that require uncertain reasoning. Assuming a UNIX-like
environment, a typical session might look like the following:

\begin{itemize}
	\item $> \mbox{ghci}$
	\item $> \mbox{import SL}$
	\item $> \mbox{data Atoms} = \mbox{Red} | \mbox{Green} | \mbox{Blue}$
	\item $> \mbox{let mass = fromList} [ ([Red], 1/4), ([Green], 1/4), ([Green, Blue], 1/3) ]$
	\item $> \mbox{expectation} [Blue]$
	\item $\mbox{Some value here}$
\end{itemize}

\par
The workbench will allow the users to experiment with the full range of Subjective Logic operators in
an incremental manner.

\subsection{An embeddable reasoning engine}

\par
Our framework will comprise of a set of modules that can be imported not only from GHC's REPL, as seen
in the previous section, but also from arbitrary Haskell programs. This allows users to construct
real-world applications that utilize our framework. 

\par
Furthermore we propose to construct a foreign interface to the C programming language. This will allow
for users to interface with our framework from any language that supports calling arbitrary C functions.
Examples of such languages are C++, Python, and Ruby.

\subsection{Ease of extension}

\par
We plan to utilize monads from Category Theory as an abstraction mechanism to support
extension. Monads have gained popularity as a method of representing effectful computation
in functional programming languages. In our case, we will be utilizing a Reasoner monad that,
when given a sum-type representing the atoms of our frame of discernment, and a type that
represents the underlying probablistic logic system (e.g. Subjective Logic), behaves similar to
that of a Reader monad, which allows for computations encapsulated within to access the
belief mass assignment that underpins the more complex opinions built on top of our framework.

\par
In more detail, we have a polymorphic type Reasoner a l c, where a is the set of atoms, and l is
the probablistic logic. By plugging those types, we obtain a new type that is parameterized over
c, the computation result. For example, if we have the following types

$$\mbox{data Balls} = Red | Green | Blue$$
$$\mbox{data SLogic -- implementation details omitted}$$
$$\mbox{type SLReasoner c = Reasoner Balls SLogic c}$$

\par
And thus SLReasoner is a new monad that can be combined using the standard monad operators bind, join,
etc. Therefore extending our framework to support new probablistic logics simply requires the user
to define a new type that supports the minimum required operators for combining opinions. That type
can then be slotted into our Reasoner type.



\subsection{Efficiency}

\par
The naive descriptions of the operators in Subjective Logic have exponential runtime with respect
to the size of the frame of discernment because the most general form of opinion - the hyper
opinion - is computed over the powerset of the frame. We propose exploring the use of memoization
in order to curtain this runtime by re-using pre-calculated subexpressions.
We also expect that Haskell's non-strict evaluation strategy will also lend a hand to
increasing the efficiency of the operators, as any unused values will never be computed.

\section{Justification for our approach}

\par
TODO

\section{Verifying our work}

\par
We plan to verify the extensibility of our framework by implementing not only the
operators of Subjective Logic, but also functions for working with Dempster-Shafer
theory. We strongly believe that this will suitably demonstrate that our framework can
easily be extended to support various forms of probablistic reasoning.

\par
To verify our efficiency claims, we propose to perform a thourough complexity analysis
of the implementations of the Subjective Logic operators. We will compare these results
with the complexities of the naive implementations that do not leverage memoization in
order to solidify our claim. Furthermore we will perform proofs of termination.

\par
Finally to verify the correctness of the Subjective Logic operators themselves, we
will re-implement an analysis of a Bayesian network that was demonstrated by Josang
and verify that our framework delivers the same results. We may perhaps also experiment
on a much larger network in order to emperically verify our claims of efficiency.

\section{Expected outcomes}

\par
We expect to have achieved the first extensible framework for experimenting with
Subjective Logic that also supports the ability to be embedded into larger more complex
applications. Furthermore we expect to have delivered the first thourough complexity
analysis of the Subjective Logic operators. We hope that through this thesis we will be
able to deliver an efficient, modular framework with which further research can be
based upon.


\section{Further research}

\par
TODO

\section{References}

\par
TODO


\end{document}
