\documentclass[a4paper]{article}

\title{A modular framework for aiding in the construction of uncertain reasoning systems}
\author{Bryan St. Amour}

\begin{document}

\maketitle

\section{The problem addressed}

\par
The main problem that we wish to address is that aside from the Java demos provided
by Josang, there does not appear to be any off-the-shelf framework for experimenting
with, and embedding subjective logic into applications. Software that requires a form
of artifical reasoning and wish to utilize subjective logic appear to be doomed to
rewrite the core operators by hand, which can lead to buggy, slow software.

\section{previous work on the problem}

\par
At the time of this writing, we are unaware of any other frameworks that have been
developed for users wishing to leverage the power of Subjective Logic. However we
are continuing to search for similar work.

\section{Our approach}

\par
We propose to develop a framework for subjective logic that

\begin{itemize}
	\item Can be utilized as a standalone workbench, much like a Read-eval-print loop such as various lisps.
	\item Can be embedded into larger applications which require artificial reasoning.
	\item Is easily extendable to support more kinds of probablistic logics (e.g. Dempster-shafer theory).
	\item Is efficient.
\end{itemize}

\par
We address the above items in the proceeding sections.
Our language of implementation is to be the pure functional programming language Haskell, as it's purity
and non-strict semantics offer various advantages over contemporary imperative languages.

\subsection{A Standalone Workbench}

\par
We plan to leverage the GHC compiler's read-eval-print loop (REPL) in order to create an easy-to-use environment
for which users can model and explore situations that require uncertain reasoning. Assuming a UNIX-like
environment, a typical session might look like the following:

\begin{itemize}
	\item $> \mbox{ghci}$
	\item $> \mbox{import SL}$
	\item $> \mbox{data Atoms} = \mbox{Red} | \mbox{Green} | \mbox{Blue}$
	\item $> \mbox{let mass = fromList} [ ([Red], 1/4), ([Green], 1/4), ([Green, Blue], 1/3) ]$
	\item $> \mbox{expectation} [Blue]$
	\item $\mbox{Some value here}$
\end{itemize}

\par
The workbench will allow the users to experiment with the full range of Subjective Logic operators in
an incremental manner.

\subsection{An embeddable reasoning engine}

\par
Our framework will comprise of a set of modules that can be imported not only from GHC's REPL, as seen
in the previous section, but also from arbitrary Haskell programs. This allows users to construct
real-world applications that utilize our framework. 

\par
Furthermore we propose to construct a foreign interface to the C programming language. This will allow
for users to interface with our framework from any language that supports calling arbitrary C functions.
Examples of such languages are C++, Python, and Ruby.

\subsection{Ease of extension}

\par
We plan to utilize monads from Category Theory as an abstraction mechanism to support
extension. 

% TODO: The following is a bit murky. Clean it up.

\par
In more detail, we propose to develop a polymorphic type Reasoner t c a, with t being a sum-type
representing the atoms that comprise the frame of discernment, c being a type of probablistic logic
calculus (e.g. Subjective Logic), and a being the result of a computation within this type. If we
consider all legal types in a Haskell program, these paired with the set of all unary functions over
these types form a category. Call such a category Hask. Now, consider the sub-category comprised of
all types Reasoner Atoms SubjLogic a, where Atoms and SubjLogic are fixed, and a is free to reign over
any type in Hask. Clearly this category is a sub-category of Hask, and we can prove that there exists
a monad over this sub-category, representing every closed computation within it.

\par
Therefore given an arbitrary type Atoms representing all possible items in the frame of discernment,
and a type Calc -an arbitrary probablistic logic calculus, the type Reasoner Atoms Calc a contains a
unique monad, and we can therefore take advantage of the many monadic operators defined in Haskell
to represent arbitrary computations within any defined probablistic logic.

\subsection{Efficiency}

\par
The naive descriptions of the operators in Subjective Logic have exponential runtime with respect
to the size of the frame of discernment because the most general form of opinion - the hyper
opinion - is computed over the powerset of the frame. We propose exploring the use of memoization
in order to curtain this runtime by re-using pre-calculated subexpressions.
We also expect that Haskell's non-strict evaluation strategy will also lend a hand to
increasing the efficiency of the operators, as any unused values will never be computed.

\section{Justification for our approach}

\par
TODO

\section{Verifying our work}

\par
We plan to verify the extensibility of our framework by implementing not only the
operators of Subjective Logic, but also functions for working with Dempster-Shafer
theory. We strongly believe that this will suitably demonstrate that our framework can
easily be extended to support various forms of probablistic reasoning.

\par
To verify our efficiency claims, we propose to perform a thourough complexity analysis
of the implementations of the Subjective Logic operators. We will compare these results
with the complexities of the naive implementations that do not leverage memoization in
order to solidify our claim. Furthermore we will perform proofs of termination.

\section{Expected outcomes}

\par
We expect to have achieved the first extensible framework for experimenting with
Subjective Logic that also supports the ability to be embedded into larger more complex
applications. Furthermore we expect to have delivered the first thourough complexity
analysis of the Subjective Logic operators. We hope that through this thesis we will be
able to deliver an efficient, modular framework with which further research can be
based upon.


\section{Further research}


\end{document}
