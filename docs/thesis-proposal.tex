\documentclass{beamer}

\usepackage{fancyvrb}
\usepackage{stmaryrd}

\DefineVerbatimEnvironment{code}{Verbatim}{fontsize=\small}
\DefineVerbatimEnvironment{example}{Verbatim}{fontsize=\small}
\newcommand{\ignore}[1]{}

\mode<presentation>
{ \usetheme{Antibes} }

\title{A Monad-based, Lazy, Purely Functional Subjective Logic Combinator Library}

\author{Bryan St. Amour}


% The following will inject the table of contents with the current section
% highlighted between each section.

%\AtBeginSection[]
%{
%  \begin{frame}<beamer>
%  \frametitle{Outline}
%  \tableofcontents[currentsection]
%  \end{frame}
%}

\begin{document}

%===============================================================================
%
% Front matter.
%
%===============================================================================

\begin{frame}
\titlepage
\end{frame}

\begin{frame}

Thesis committee

\begin{itemize}
  \item \emph{Advisor:} Dr. Robert Kent
  \item \emph{Internal Reader:} Dr. Richard Frost
  \item \emph{External Reader:} Dr. Rick Caron (Math/Stats)
\end{itemize}

\end{frame}

%-------------------------------------------------------------------------------

\begin{frame}
\tableofcontents
\end{frame}

%-------------------------------------------------------------------------------

%===============================================================================
%
% Thesis intro.
%
%===============================================================================

\section{Introduction}

\begin{frame}
\frametitle{Introduction - Decision Support}

Decision support systems are systems that support decision making
through the use of analytics, modelling, etc \cite{sprague_framework_1980}.

Example application areas include

\begin{itemize}
  \item Clinical \cite{berner2007clinical}
  \item Business \cite{klein_knowledge-based}
  \item Health and Safety \cite{kent2010application}
\end{itemize}

\end{frame}

%===============================================================================
%
% Introduction to Subjective Logic
%
%===============================================================================

\section{Subjective Logic}

\begin{frame}
\frametitle{Subjective Logic}

Subjective Logic is a probablistic logic for uncertain reasoning
\cite{josang_logic_2001}.

Shares some similarities with \emph{belief theory}.

\end{frame}

%-------------------------------------------------------------------------------

\begin{frame}
\frametitle{Frame of Discernment}

A \emph{frame of discernment} is a set of mutually atomic elements. e.g.
solid colours, states in an automata, etc.

Some examples

$\Theta = \lbrace \mbox{Red, Blue, Yellow} \rbrace$

$\Theta = \lbrace \mbox{Male, Female} \rbrace$

$\Theta = \lbrace \mbox{Attack, Remain stationary} \rbrace$

\end{frame}

%-------------------------------------------------------------------------------

\begin{frame}
\frametitle{Reduced Powerset}

The \emph{reduced powerset} of a frame $\Theta$ is defined as $2^{\Theta} \setminus \lbrace \emptyset, \Theta \rbrace$.

Denoted as $\mathbb{R}^\Theta$.

e.g.

$\Theta = \lbrace \mbox{Red, Blue, Yellow} \rbrace$

$\mathbb{R}^\Theta = \lbrace
  \lbrace \mbox{Red} \rbrace,
  \lbrace \mbox{Blue} \rbrace,
  \lbrace \mbox{Yellow} \rbrace,
  \lbrace \mbox{Red, Blue} \rbrace,
  \lbrace \mbox{Red, Yellow} \rbrace,
  \lbrace \mbox{Blue, Yellow} \rbrace
  \rbrace$

\end{frame}

%-------------------------------------------------------------------------------

\begin{frame}
\frametitle{Belief Distributions}

A \emph{belief distribution} is a vector $\vec{b}$ that denotes the amount of belief
mass assigned to elements of the reduced powerset.

$$
\sum_{x \in \mathbb{R}\left(\Theta\right)} \vec{b}_\Theta \left(x \right) \leq 1 \mbox{, where }
    \vec{b}_\Theta\left(x\right) \in \lbrack 0, 1 \rbrack, \forall x \in \mathbb{R}\left(\Theta\right)
$$

and

$$
u_\Theta = 1 - \sum_{x \in \mathbb{R}\left(\Theta\right)} b_\Theta \left( x \right)
$$

is the \emph{uncertainty mass}.

\end{frame}

%-------------------------------------------------------------------------------

\begin{frame}
\frametitle{Belief Distributions}

Belief distributions and uncertainty can be mapped to \emph{basic belief assignments} from
\emph{Belief Theory}:


\begin{table}
\centering

\begin{tabular}{|l|l|}
  \hline
  Subjective Logic & Belief Theory \\
  \hline
  $\vec{b}_\Theta\left( x \right)$ & $m_\Theta\left( x \right)$ \\
  $u_\Theta$                 & $m_\Theta \left(\Theta\right)$ \\
  \hline
\end{tabular}

\end{table}

\end{frame}

%-------------------------------------------------------------------------------

\begin{frame}
\frametitle{Focal Elements}

Any subset of $\Theta$ that has non-zero mass distributed to it is called a
\emph{focal element}. Focal elements can be \emph{class-1} elements (singletons),
\emph{class-2} elements (sets of cardinality 2), ...

\end{frame}

%-------------------------------------------------------------------------------

\begin{frame}
\frametitle{Base Rates}

Base rates represent a priori belief. For a frame of cardinality k, the
\emph{default base rate} for each element is $\frac{1}{k}$, though other values
can be used.

Base rate vectors are additive:

$$
\sum_{x \in \Theta} \vec{a}\left(x\right) = 1
$$

A subset of the frame of cardinality n has a base rate of $\frac{n}{k}$.

\end{frame}

%-------------------------------------------------------------------------------

\begin{frame}
\frametitle{Opinions in Subjective Logic}

In SL, opinions come in three basic forms:

\begin{itemize}
  \item Binomial Opinions
  \item Multinomial Opinions
  \item Hyper Opinions
\end{itemize}

where hyper opinions are the most general. We can represent opinions as functions:

$$
\omega_\Theta = \langle \vec{b}_\Theta, u_\Theta, \vec{a}_\Theta \rangle
$$

Where $\vec{b}$ is a vector of beliefs assigned to focal elements,
$u$ is the uncertainty mass, and
$\vec{a}$ is a base rate vector over elements of the frame.

\end{frame}

%-------------------------------------------------------------------------------

%-------------------------------------------------------------------------------
% BINOMIAL OPINIONS
%-------------------------------------------------------------------------------

\begin{frame}
\frametitle{Binomial Opinions}

A \emph{binomial opinion} is an opinion defined over a binary frame of discernment, or
a binary partitioning of an n-ary frame.

Sometimes it is useful to distinguish an element $x$, and represent the frame as
$\Theta = \lbrace x, \lnot x \rbrace$. In this case, we define a binomial opinion as
the tuple

$$
\omega_x = \langle b_x, d_x, u_x, a_x \rangle
$$


\end{frame}

%-------------------------------------------------------------------------------

\begin{frame}
\frametitle{Binomial Opinions}

e.g. $\Theta = \lbrace \mbox{Red, Blue} \rbrace$.
Let $b_\Theta\left(Red\right) = 0.5, b_\Theta\left(Blue\right) = 0.4$. Then we can
define the binomial opinion of the colour being red as

$$
\omega_{Red} = \langle 0.5, 0.4, 0.1, 0.5 \rangle
$$

\end{frame}

%-------------------------------------------------------------------------------

\begin{frame}
\frametitle{Binomial Opinions}

Binomial opinions can be mapped to \emph{Beta distributions} using the following relations:

$$
\begin{array}{l}
  b = \frac{r}{W + r + s} \\
  d = \frac{s}{W + r + s} \\
  u = \frac{W}{W + r + s}
\end{array}
$$

where $W$ is a weighting parameter (typically set to 2.)

\end{frame}

%-------------------------------------------------------------------------------

\begin{frame}
\frametitle{Binomial Coarsening}

Binomial opinions can also be built from binary partitions of frames.

e.g. $\Theta = \lbrace \mbox{Red,Orange,Yellow,Green,Blue,Purple} \rbrace$

... Split into two sets $Primary = \lbrace \mbox{Red,Yellow,Blue} \rbrace$, and
$\lnot Primary = \lbrace \mbox{Orange,Green,Purple} \rbrace$ ...

gives us a ``binary frame'' $\Theta' = \lbrace \mbox{Primary}, \lnot \mbox{Primary} \rbrace$.

$$
\omega_{Primary} = \langle b_{Primary}, d_{Primary}, u_{Primary}, a_{Primary} \rangle
$$

\end{frame}

%-------------------------------------------------------------------------------

\begin{frame}
\frametitle{Binomial Coarsening}

How do we compute the coarsened values?

\end{frame}

%-------------------------------------------------------------------------------

%-------------------------------------------------------------------------------
% MULTINOMIAL OPINIONS
%------------------------------------------------------------------------------

\begin{frame}
\frametitle{Multinomial Opinions}

\emph{Multinomial opinions} are defined over frames with possibly more than 2 elements.
All binomial opinions are multinomial opinions. Multinomials are \emph{more general}.

Restriction: only \emph{class-1} elements of $\mathbb{R}^\Theta$ can be focal elements.
Thus, the function

$$
\omega_\Theta = \langle b_\Theta, u_\Theta, a_\Theta \rangle
$$

has $2k + 1$ parameters, where $k$ is the cardinality of $\Theta$.

\end{frame}

%-------------------------------------------------------------------------------

\begin{frame}
\frametitle{Multinomial Opinions}

Multinomials can be mapped to \emph{Dirichlet distributions}.

\begin{eqnarray}
  b(x_i) &=& \frac{r(x_i)}{W + \sum_{j = 1}^k r(x_j)} \\
  u      &=& \frac{W}{W + \sum_{j = 1}^k r(x_j)}
\end{eqnarray}

\end{frame}

%-------------------------------------------------------------------------------

%-------------------------------------------------------------------------------
% HYPER OPINIONS
%------------------------------------------------------------------------------

\begin{frame}
\frametitle{Hyper Opinions}

No restrictions on focal elements. Anything goes. Being the most general, hyper
opinions are also simply called \emph{Subjective Opinions}. Thus, the function

$$
\omega_\Theta = \langle b_\Theta, u_\Theta, a_\Theta \rangle
$$

has $2^{k} + k + 1$ parameters.

All multinomial opinions are also hyper opinions.

\end{frame}

%-------------------------------------------------------------------------------

\begin{frame}
\frametitle{Hyper Opinions}

Hyper opinions can be mapped to \emph{Hyper-dirichlet distributions}.

\end{frame}

%-------------------------------------------------------------------------------

%-------------------------------------------------------------------------------
% SOME SL OPERATORS.
%------------------------------------------------------------------------------

\begin{frame}
\frametitle{Example SL Operators}


\end{frame}

%-------------------------------------------------------------------------------

\begin{frame}
\frametitle{Benefts}

\begin{itemize}
  \item Wealth of operators for working with beliefs
     \footnote{\url{http://folk.uio.no/josang/papers/subjective_logic.pdf}}
  \item Beta, Dirichlet, Hyper-dirichlet interpretations
  \item Easy to model many situations
    \cite{josang2008conditional}, \cite{josang2006trust}, \cite{kent2010application}
\end{itemize}

\end{frame}

%-------------------------------------------------------------------------------

\begin{frame}
\frametitle{Drawbacks}

\begin{itemize}
  \item No widely available frameworks/toolkits/libraries!
\end{itemize}

There exists an online demo\footnote{\url{http://folk.uio.no/josang/sl/BV.html}},
but we cannot find any other published implementations.

\end{frame}

%===============================================================================
%
% Research focus + thesis statement.
%
%===============================================================================

\section{Thesis Statement}

\begin{frame}
\frametitle{Thesis Statement}

Is it possible to construct a \emph{lazy, purely functional combinator library} for Subjective
Logic using \emph{monads}?

\begin{itemize}
  \item \emph{Lazy:} Only compute what's necessary. Memoize large computations. Based
    on \emph{Graph Reduction}.
  \item \emph{Purely Functional:} Computations are functions in the mathematical sense.
    No side effects. Based on \emph{$\lambda$-calculus}.
  \item \emph{Combinators:} All expressions are built from a small set of operators that
    can be combined through function application.
  \item \emph{Monads:} Mathematical objects from \emph{Category Theory}. Have gained
    popularity in Functional Programming for controlling effects (cite).
\end{itemize}

\end{frame}

%-------------------------------------------------------------------------------

\begin{frame}
\frametitle{Research Objectives}

Through our research we expect to achieve the following objectives.

\begin{itemize}
  \item Implement all Subjective Logic operators as currently published by Josang
    using the \emph{Haskell} programming language.
  \item Perform a complexity analysis on the operators. Perhaps discover more efficient
    methods for implementation.
  \item Prove that the operators terminate for all finite inputs.
\end{itemize}

\end{frame}

%-------------------------------------------------------------------------------

\begin{frame}
\frametitle{Research Objectives}

Furthermore, we hope to demonstrate the effectiveness of our combinator
library by

\begin{itemize}
  \item Developing a reasoning application which uses our combinators as an
    external library.
  \item Develop a front-end so that our combinators may communicate
    with an external web application.
  \item Experiment with possible extensions of Subjective Logic.
\end{itemize}

\end{frame}

%===============================================================================
%
% What the hell are monads?
%
%===============================================================================

\section{Monads}

\begin{frame}
\frametitle{Monads}

A monad, formally, is a special kind of \emph{functor} from Category Theory \cite{mac1998categories}. In
practice, it is a \emph{data type} M with the following operations \cite{Wadler:1992:EFP:143165.143169}:

\begin{itemize}
  \item $\mbox{unitM :: } \alpha \rightarrow \mbox{M } \alpha$.
  \item $\mbox{bindM :: } \mbox{M } \alpha \rightarrow \left(\alpha \rightarrow \mbox{M } \beta\right) \rightarrow \mbox{M } \beta$
\end{itemize}

\end{frame}

%-------------------------------------------------------------------------------

\begin{frame}[fragile]
\frametitle{Examples}

An \emph{optional} data type: either contains a value or does not.

\begin{code}
data Optional a = Value a | Nothing

instance Monad Optional where
  return x = Value x        -- unitM

  Nothing   >>= f = Nothing -- bindM
  (Value x) >>= f = f x
\end{code}

\end{frame}

%-------------------------------------------------------------------------------

\begin{frame}[fragile]
\frametitle{Examples}

Example usage:

\begin{code}
safeDivide :: Int -> Int -> Optional Int
safeDivide x 0 = Nothing
safeDivide x y = x / y

result = safeDivide a b >>= safeDivide c
                        >>= safeDivide d
\end{code}

If any of the above fails, then entire computation fails.

\end{frame}

%-------------------------------------------------------------------------------

\begin{frame}[fragile]
\frametitle{Examples}

Another example: carrying around \emph{state}

\begin{code}
data State s a = State { unState :: s -> (s, a) }

instance Monad (State s) where
  return x = State (\st -> (st, x))
  sa >>= f = State (\st -> let (st', a)  = unState sa st
                               sb        = f a
                               (st'', b) = unState sb st'
                           in b)
\end{code}

\end{frame}

%-------------------------------------------------------------------------------

\begin{frame}[fragile]
\frametitle{Monad Laws}

Any type M that has a monadic instance should also abide by the following
laws.

\begin{itemize}
  \item \emph{Left unit:}
    \begin{code}
      return x >>= k = k x
    \end{code}

  \item \emph{Right unit:}
    \begin{code}
      m >>= return = m
    \end{code}

  \item \emph{Associativity:}
    \begin{code}
      m >>= (\x -> (k x) >>= h)
        = (m >>= (\x -> (k x)) >>= h)
    \end{code}

\end{itemize}

\end{frame}

%-------------------------------------------------------------------------------

%\begin{frame}
%\frametitle{Other Examples}

%Other examples of monads include

%\begin{itemize}
%  \item
%\end{itemize}

%\end{frame}

%-------------------------------------------------------------------------------

\begin{frame}
\frametitle{Why Monads?}

We propose to use monads for two reasons:

\begin{itemize}
  \item \emph{Error propogation:} If any sub expression fails, we carry the
    error to the top, curtailing further computations.
  \item \emph{Carrying around state:} The state monad allows us to carry state
    (belief mass assignments, base rates, etc) throughout our operators implicitly.
\end{itemize}

\end{frame}

%-------------------------------------------------------------------------------

\begin{frame}[fragile]
\frametitle{Why Monads?}

Error reporting:

\begin{code}
data SLValue a = SLValue a | SLError String
instance Monad SLValue where
  return x = SLValue x
  (SLValue x) >>= f = f x
  (SLError s) >>= _ = SLError s
\end{code}

We can detect and report errors to users. Computation stops after a single
error is detected thanks to laziness.

\end{frame}

%-------------------------------------------------------------------------------

\begin{frame}[fragile]
\frametitle{Why Moands?}

Carrying state:

\begin{code}
data SLStateObj = SLStateObj {
  frames :: [Frame]
  distribs :: [BeliefDistribution]
  baseRates :: [BaseRateVector]
}
type SLState a = State SLStateObj a
\end{code}

We carry around the state required for the operators to work behind the scenes.

\end{frame}

%-------------------------------------------------------------------------------

\begin{frame}[fragile]
\frametitle{Subjective Logic Operators}

Now, operators can be defined like the following:

\begin{code}
add :: SLState Opinion -> SLState Opinion -> SLState Opinion
op1 `add` op2 = -- details omitted

mult :: SLState Opinion -> SLState Opinion -> SLState Opinion
op1 `mult` op2 = -- details omitted

eqn :: SLState Opinion
eqn = (op1 `mult` op2) `add` (op1 `mult` op3)
                       `add`
                       ...
                       `add` (op1 `mult` opN)

result = runSL eqn myState
\end{code}

\end{frame}

%===============================================================================
%
% How far along are we toward completion of the work?
%
%===============================================================================

\section{Current Progress / Roadmap Toward Completion}

\begin{frame}
\frametitle{Library Implementation}

So far we have implemented the core structures of Subjective Logic:

\begin{itemize}
  \item Subjective opinions: binomial, multinomial and hyper.
  \item The monads from which we will be constructing our operator set.
  \item Basic operators between opinions.
\end{itemize}

\end{frame}

%-------------------------------------------------------------------------------

\begin{frame}
\frametitle{What's Left?}

\begin{itemize}
  \item Remaining operators.
  \item Complexity analysis of the operators.
  \item Proofs of termination.
  \item Demo applications.
\end{itemize}

\end{frame}

%===============================================================================
%
% Close it off.
%
%===============================================================================

\section{Conclusion}

\begin{frame}
\frametitle{Conclusion}

Subjective Logic is a fairly new, powerful logic for uncertain reasoning. The lack
of tooling, however, is an issue that needs to be overcome.

We propose to develop a comprehensive library of operators, alongside an analysis of
of complexity, and proofs of termination.

In addition we propose to develop a set of demo applications to display the flexibility
of our library.
\end{frame}


%===============================================================================
%
% Citations.
%
%===============================================================================

\section{References}

\begin{frame}[allowframebreaks]
\frametitle{References}

\bibliographystyle{plain}
\bibliography{bibliography}

\end{frame}

%-------------------------------------------------------------------------------

\end{document}
