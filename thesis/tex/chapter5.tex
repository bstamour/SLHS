\documentclass[thesis.tex]{subfiles}

\begin{document}


\chapter{Results and Analysis}
\label{chap:results-and-analysis}

In this chapter we will analyze SLHS by proving that the combinators terminate for
all input expressions, analyze the complexity of the Subjective Logic operators,
discuss how Haskell's strong type system and its support for monads has affected the
design of SLHS, and finally we will demonstrate the power of SLHS by showcasing some
example computations.


\section{Proof of Termination}

In this section we will perform a termination analysis of the \emph{run} function. The
run function takes in a subjective logic expression and an initial state, and returns
either the computed value or an error message. We will prove that run terminates for
subjective logic expressions of arbitrary length.

Our strategy for proving termination is as follows: we utilize a function $|\cdot|$ that
maps each subjective logic expression $e$ to the number of sub-expresssions contained in
$e$, including $e$ itself. As \emph{run} recursively computes the values of the
sub-expressions, we will show that the value of $|e|$ decreases at each step, concluding
when $|e|$ is 1, and \emph{run} simply returns the final value. Therefore we can conclude
that \emph{run} terminates because the set of ordinals is \emph{well-founded}, that is there
cannot exist infinitely descending chains.

\begin{lemma}
  The \emph{return} function introduces a new sub-expression.
\end{lemma}

\begin{proof}
  The function \emph{return} in Haskell has the following signature:

  \begin{spec}
    return :: Monad m => a -> m a
  \end{spec}

  That is, for any monad m, for every object $x$ of type $a$, \emph{return x} constructs
  an object of type \emph{m a}. Since \emph{SLExpr} is a monad, \emph{return} constructs
  a new subjective logic expression containing a single value. We will use this result to
  assist us in showing that the \emph{run} function's measure decreases at every step.
\end{proof}






\begin{theorem}
  For every subjective logic expression $e = e_1 \cdot e_2 \cdot \dots \cdot e_k$, where $\cdot$
  can be any binary subjective logic operator, the computation \emph{run e} terminates.
\end{theorem}

\begin{proof}
  By induction on the length of $e$. If we can show that
  $|run\,e_1 \cdot \dots \cdot e_k| < |e_1 \cdot \dots \cdot e_k \cdot e_k|$ for all $k \geq 0$, then
  \emph{run} terminates.

  Base Case $e = e_1$: In this case, $|e| = 1$, and since \emph{run} simply applies the initial
  state to the function contained within $e$ without adding any new objects of type \emph{SLExpr},
  in other words $|run\,e| = 0$, \emph{run e} terminates.

  Inductive Hypothesis: Assume \emph{run} terminates for the expression $e = e_1 \cdot e_2 \cdot \dots \cdot e_k$.
  Given the expression $e' = e \cdot e_{k+1}$, we must prove that $|run\,e'| < |e'|$.

  Inductive Proof: Since we are adding exactly one new sub-expression to $e$ to form $e'$,
  $|e'| = |e| + 1$. Now, all binary operators of SLHS essentially have the same form:

  \begin{spec}
    op e1 e2 = e1 >>= \e -> e2 >>= \e' -> return (combine e e')
  \end{spec}

  That is, we unpack each expression and then combine them together in some meaningful way to produce
  a new value of type \emph{SLExpr}. Let us analyze the first monadic bind operator.

  \begin{spec}
    e1 >>= \e -> e2 >>= \e' -> return (combine e e')
  \end{spec}

  first calls \emph{run} on $e1$, then passes the result of that computation to the lambda function

  \begin{spec}
    \e -> e2 >>= \e' -> return (combine e e')
  \end{spec}

  and calls \emph{run} on the result. Inside the nested lambda expression, the second monadic bind operator
  calls \emph{run} on $e2$, passing the result into the lambda expression

  \begin{spec}
    \e' -> return (combine e e')
  \end{spec}

  and then invoking \emph{run} on \emph{that} result. The innermost invocation of \emph{run} makes a call
  to \emph{return}, thus inserting a new object of type \emph{SLExpr}. Combined together with the two
  invocations of \emph{run} on the input expressions, we have

  \begin{equation*}
  \begin{split}
    |run\,e \cdot e_{k + 1}|& = |run\,e| + |run\,e_{k+1}| + |return\,x| \\
                     & = |run\,e| + 0 + 1 \\
                     & < |e| + 1 \\
                     & = |e \cdot e_{k+1}|
  \end{split}
  \end{equation*}

\end{proof}



%
% Make sure the mention binomial opinions are O(1).
%


\section{Analysis of Complexity}

In this section we will analyze the time complexity of a few of the SLHS operators. We will initially
analyze the complexity of belief constraining to demonstrate how computationally expensive it is to
work with hyper opinions, which are defined over the reduced powerset of the frame of discernment.
Next we will analyze the complexity of belief fission, an operator defined over multinomial opinions.
Lastly, we will analyze the complexity of multinomial multiplication.

We do not claim that the implementations of the operators are optimal. In fact, our implementations
are very sensitive to our choice of data structure for representing belief assignments: the red-black
tree. Iterating through the entire belief mass assignment takes $O (n)$ time, but finding an individual
element takes $O (\log n)$ time. Alternative representations may possibly be more efficient, and we leave
that for future work.


\begin{theorem}
  Belief constraining has time complexity $O ((2^n - 2)^3 \log (2^n - 2))$,
  where $n$ is the cardinality of the frame of discernment.
\end{theorem}

\begin{proof}
  Since belief constraining is defined over hyper opinions, let $m = 2^n - 2$ be the cardinality
  of the reduced powerset of the frame. Computing the \emph{conflict} requires finding all elements of
  the powerset that share overlap and adding together their assigned belief masses. This operation
  takes $O (m^2)$ time for the iteration, and $O (\log m)$ for looking up the belief masses. Therefore
  conflict takes $O (m^2 \log m)$ time.

  Computing the new belief mass requires computing the \emph{Harmony} for every element of the powerset.
  Computing the harmony takes $O (m^2)$ time per element, resulting in a time complexity of $O (m^3 \log m)$
  for computing the new belief mass.

  Computing the uncertainty requires computing the conflict, which we have already computed as a part of
  the new belief mass.

  Atomicity requires iterating over the entire reduced powerset, and thus requires $O (m \log m)$ time.

  Therefore the total time complexity for belief constraining is
  $O (m^3 \log m + m^2 \log m + m \log m) = O (m^3 \log m) = O ((2^n - 2)^3 \log (2^n - 2))$.
\end{proof}






\begin{theorem}
  Multinomial fission has time complexity $O (n)$, where $n$ is the cardinality of the frame of discernment.
\end{theorem}

\begin{proof}
  Computing the normalizing constant takes $O (n)$ time. Since computing the new beliefs and uncertainties
  requires iterating over each element of the frame of discernment, each takes $O (n)$ time. Therefore, the
  time complexity for fission is $O (n)$.
\end{proof}






\begin{theorem}
  Multinomial multiplication has time complexity $O (m \log m \times n \log n)$.
\end{theorem}

\begin{proof}
  The \emph{expect x y} function takes $O (\log m + \log n)$ time, since it needs to perform
  lookups on each frame. Computing the uncertainty takes $O (m \log m \times n \log n)$ time,
  computing the new atomicity takes $O (m \log m \times n \log n)$ time, and computing the new
  belief also takes $O (m \log m \times n \log n)$ time. Therefore the entire time complexity is
  $O (m \log m \times n \log n)$.
\end{proof}




%
% Maybe mention other operators that are similar to the ones analyzed.
%





\section{Use of Haskell's Type System}

In this section we will discuss how SLHS leverages Haskell's type system to catch many errors
at compile time, instead of at run time. With SLHS we have taken the motto of \emph{catch what we
can at compile time, report what we must at run time}. There are certain properties of well-formed
Subjective Logic expressions that can only be caught at run time, such as

\begin{itemize}
  \item the inputs to the binomial addition operator are subsets of the same frame
    of discernment.
  \item the inputs to the transitive discounting operator have different belief
    owners.
  \item the subset relation required for binomial subtraction is satisfied.
\end{itemize}

For other issues however, such as restricting addition to work on binomial opinions only, we can
leverage Haskell's strong typing to stop those invalid expressions from even compiling.

Consider the type signature for the binomial addition operator:

\begin{spec}
(+!) :: (ToBinomial op1, ToBinomial op2)
       => SLExpr h a (op1 h (F.Subframe a))
       -> SLExpr h a (op2 h (F.Subframe a))
       -> SLExpr h a (Binomial h (F.Subframe a))
\end{spec}

What this tells us is that addition takes in two parameters, \emph{op1} and \emph{op2}, each wrapped in
the \emph{SLExpr} monad. These two opinion types must be convertible to binomials, as they must belong to
the type class \emph{ToBinomial}. Secondly, since opinion types are parameterized over the type of elements
contained within the associated frame of discernment, we enforce that those elements are themselves
\emph{subframes}. We can ensure that addition only happens between types convertible to binomial opinions
and whose frames of discernment are themselves frames. We cannot check at compile time whether the two
frames are paritions of the same underlying frame, but we can still catch quite a bit of obvious mistakes.


\section{The Use of Monads}

In this section we will describe the roll that monads have played in the design of SLHS. As mentioned
previously, the \emph{SLExpr} type that represents Subjective Logic expressions is a function from
a world state, \emph{SLState}, to some output value. \emph{SLExpr} forms a monad, and thus we are
able to use all of Haskell's built-in support for monads when writing computations involving
objects of type \emph{SLExpr}. In particular, \emph{SLExpr} is a special kind of \emph{state monad},
where the state carried through the computation is an \emph{SLState} object.

Because they are monads, objects of type \emph{SLExpr} can be glued together using the various
operators and functions in the Haskell standard library. One function that we use quite frequently
in the implementation of SLHS is the \emph{liftM} function, which takes an ordinary function from
some type $a$ to type $b$, and converts it into a function from type $M\,a$ to $M\,b$, where $M$ is
any monad. This allows us to use functions such as \emph{toBinomial} directly on objects of type
\emph{SLExpr} without having to unwrap them first.

Another benefit of \emph{SLExpr} being a monad is that we are able to use Haskell's \emph{do-notation}
in order to simplify our code. Do-notation allows us to write code of the form

\begin{spec}
z = mx >>= \x -> my >>= \y -> return (x + y)
\end{spec}

where each and every invocation of the bind operator must be explicitly written, as

\begin{spec}
z = do x <- mx
       y <- my
       return (x + y)
\end{spec}

This syntactic sugar not only allows the implementation of SLHS to be written more
concisely in many cases, but it also extends to users of SLHS as well. Complicated
Subjective Logic exprressions can be broken down into smaller pieces, and then glued
together in a style that looks very imperative:

\begin{spec}
expr = do e1 <- getMultinomial ``Alice'' 0
          e2 <- getMultinomial ``Bob'' 0
          e3 <- e1 `times` e2
          e4 <- e3 `cFuse` (getHyper ``Clark'' 0)
          return e4
\end{spec}

which may help programmers who are more acustomed to writing programs in more mainstream
languages such as \emph{Python} or \emph{Ruby}. In the next section we will demonstrate how
problems involving Subjective Logic can be modelled and executed using SLHS.



\section{Example Computations}

In this section we will demonstrate the use of SLHS on a selection of examples provided in the
Subjective Logic literature.



\subfile{./SLHS/examples/Ex1.lhs}
\subfile{./SLHS/examples/Ex2.lhs}



\section{Summary}

In this chapter we presented a termination analysis for the \emph{run} function of SLHS, proving
that it terminates for all expressions. We then provided a complexity analysis for a selection
of Subjective Logic operators. We also discussed how Haskell's type system is leveraged in SLHS
to catch problems with Subjective Logic expressions at compile time, and we also provided some
example calculations. In the next chapter we will conclude this thesis and discuss areas in which
we feel SLHS can be improved.



\end{document}
