\documentclass[thesis.tex]{subfiles}

\begin{document}

\chapter{Background Information}
\label{chap:background-information}

In this chapter we will give a brief introduction to the relevant background material pertaining
to this thesis. We will begin with a discussion of \emph{decision support systems}, followed by
an overview of \emph{artificial reasoning}. Next we will discuss \emph{Dempster-Shafer Theory}, and
then \emph{Subjective Logic}. We will then conclude with
a brief overview of the \emph{Haskell} programming language, as it is the language used for the program
examples throughout this thesis.






\section{Decision Support Systems}

Decision support systems are information systems that are designed to aide users with various
decision-making tasks \cite{sprague1980framework}. Examples of such tasks are those pertaining to management,
planning, or operations. Typically decision support systems work with the kinds of unstructured
or underspecified problems faced by managers and decision-makers in many areas; involve the
synthesis of models, analytics, and data; are targetted at non-technical people; and are designed
to be flexible and adaptable in the face of new data or changes to the working environment
\cite{sprague1980framework}. Some example decision support systems are the UDMDSS system
for health research surveys \cite{kent2010application},
and the Gate Assignment Display System (GADS) developed for United Airlines
by Texas Instruments [cite].

In his 2002 book, \emph{Decision support systems: concepts and resources for managers}
\cite{power2002decision}, Daniel J Power breaks down Decision support systems into the following
taxonomy:

\begin{itemize}
  \item Communication-driven systems: systems that allow for more than
    one person to work on a shared task.
  \item Document-driven systems: systems that allow for the storage,
    retrieval and manipulation of unstructured data documents.
  \item Data-driven systems: systems that facilitate the manipulation
    of internal company data.
  \item Model-driven systems: systems that allow for access and
    modification of various models: whether they are financial,
    simulation, statistical, or other.
  \item Knowledge-driven systems: systems that contain problem solving
    expertise for the task at hand, typically encoded as facts and
    rules.
\end{itemize}

It is in the latter, \emph{knowledge-driven systems}, that this thesis is mostly concerned with: systems
that are required to reason with (possibly incomplete) domain knowledge in order to assist the human
decision-maker with his or her task.



\section{The Dempster Shafer Theory of Evidence}











\section{Subjective Logic}

Subjective Logic is a newly emergent probabilistic logic calculus that supports reasoning
under uncertainty \cite{josang2001logic}.







\subsection{Subjective Opinions}

The primary building blocks of Subjective Logic are
objects called \emph{subjective opinions}. Given a frame of discernment $\Theta$, a subjective
opinion over $\Theta$ is a 3-tuple consisting of the following elements:

\begin{itemize}
  \item A \emph{belief vector}, $b_\Theta$, of assigned belief mass that spans the \emph{reduced power set}
    of $\Theta$. The reduced power set is defined as $R \left(\Theta\right) = 2^\Theta \setminus \lbrace \Theta, \emptyset \rbrace$.
  \item A scalar, $u_\Theta$, that represents the unassigned belief mass.
    $u_\Theta + \sum_{x \in R\left(\Theta\right)} b_\Theta\left(x\right) = 1$.
  \item A vector of a-priori belief, $a_\Theta$, that spans the frame $\Theta$.
\end{itemize}

such that the following conditions hold:

\begin{enumerate}
  \item $\forall x \in R\left(\Theta\right), b_\Theta\left(x\right) \in \lbrack 0, 1\rbrack$
  \item $\forall x \in \Theta, a_\Theta\left(x\right) \in \lbrack 0, 1\rbrack$
  \item $u_\Theta \in \lbrack 0, 1\rbrack$
  \item $u_\Theta + \sum_{x \in R\left(\Theta\right)} b_\Theta\left(x\right) = 1$
  \item $\sum_{x \in \Theta} a_\Theta\left(x\right) = 1$
\end{enumerate}

Opinions are written as $\omega^A_\Theta = \langle b^A_\Theta, u^A_\Theta, a^A_\Theta \rangle$, where
$A$ is the (optional) agent who holds that particular belief.

Elements of $R\left(\Theta\right)$ such that $b_\Theta\left(x\right) > 0$ are called \emph{focal elements}.
Subjective opinions where the focal elements are all singleton sets - that is, every focal element is
simply an element of $\Theta$ - are refered to as \emph{multinomial opinions}. Multinomial opinions
defined over frames of cardinality 2 are refered to as \emph{binomial opinions}. The most general of
opinions, subjective opinions, are also refered to as \emph{hyper opinions}. Lastly, opinions can either
be \emph{dogmatic}, when $u_\Theta$ is zero, or \emph{uncertain} otherwise.

Binomial opinions have a special notation that is used to emphasize the binary nature of the frame of
discernment. Given a frame $\Theta = \lbrace x, \lnot x \rbrace$, the binomial opinion of $x$ is written
as $\omega_x = \langle b_x, d_x, u_x, a_x \rangle$, where

\begin{itemize}
  \item $b_x$ is the belief of event $x$ being true.
  \item $d_x$ is the belief of event $x$ being false.
  \item $u_x$ is the uncertainty of whether $x$ is true or false.
  \item $a_x$ is the belief of $x$ being true prior to the collection of evidence.
\end{itemize}



\subsection{Subjective Logic Operators}












\section{Functional Programming in Haskell}

\emph{Haskell} is a strongly typed, non-strict, pure functional
programming language \cite{hudak1992report} which was initially
developed to be a common language for researchers interested in
non-strict, pure functional programming languages
\cite{hudak2007history}.
By \emph{non-strict}, we mean that Haskell
evaluates expressions in a \emph{call-by-need} manner: expressions are
only evaluated if and when they are required [cite]. Haskell is a
\emph{functional programming language}, where the meaning of
\emph{functional} is the style of programs as described by John Backus
in his Turing award lecture: \emph{Can Programming Be Liberated from
  the von Neumann Style?}\cite{backus1978can}.  Lastly, Haskell is
\emph{pure} in the sense that all functions are functions in the
mathematical sense: they depend only on their inputs to produce their
outputs. Haskell does not support the use of global variables when
writing programs.

In this section we will briefly describe the syntax of Haskell in
order to give the reader enough familiarity to understand the code
listings of chapter \ref{chap:sl-in-haskell}. This section is by no
means exhaustive in its treatment of Haskell. For readers who wish to
learn Haskell in more depth, we suggest the book \emph{Real World
  Haskell}.

Functions in Haskell are written as equations, with parameters separated
by white space. For example, the function to compute factorials can be
written as

\begin{spec}
factorial 0 = 1
factorial n = n * factorial (n - 1)
\end{spec}

All expressions in Haskell have \emph{types}. For example, the type of the literal
5 is \emph{Int}. Syntactically this is expressed as \emph{5 :: Int}. The function
\emph{factorial} above has the type \emph{factorial :: Int $\rightarrow$ Int}.

Lists in Haskell are enclosed in square braces, and their elements must be of all
the same type. As an example, the following is a valid list:

\begin{spec}
names :: [String]
names = [''John'', ''Paul'', ''George'', ''Ringo'']
\end{spec}

whereas the following is invalid:

\begin{spec}
things = [5, ''seven'', 2/3]
\end{spec}

Types in Haskell can be organized into \emph{Type Classes}, where each type in a
type class must have certain required operations defined over it. For example, consider
the following class:

\begin{spec}
class Monoid n where
    id  :: n
    (<>) :: n -> n -> n
\end{spec}

which states that a type $n$ satisfies the properties of being a \emph{Monoid} if there exists
a element $id$ of type $n$, and there exists an operator for combining elements of type $n$.
Unfortunately the additional requirement of associativity cannot be expressed in Haskell.
Instances of the Monoid class can then be defined for individual types:

\begin{spec}
instance Monoid Int where
    id = 0
    x <> y = x + y
\end{spec}

One type class in particular gets special attention in Haskell. Types that are instances of
class \emph{Monad} are very popular in functional programming, and Haskell in particular. Monads
are mathematical objects from \emph{category theory} that are prevalent throughout Haskell. Most
importantly, Haskell uses monads to model imperative state [cite], which allows Haskell to read
input from the user, and send output to the computer screen, while remaining a pure functional
language. Types that are instances of \emph{Monad} require two operations to be present:

\begin{spec}
class Monad m where
    return :: a -> m a
    (>>=)  :: m a -> (a -> m b) -> m b
\end{spec}

The first function, \emph{return}, injects an object of type $a$ into an object of type $m a$, where
$m$ is some monad. The second operator takes in an object of type $m a$ on the left hand side, and
a function $f$ from $a$ to $m b$ on the right hand side, and returns an object of type $m b$.
Informally, the operator unwraps the object of type $a$ from the object of type $m a$, and then applies
the function to it to obtain a result.




\section{Summary}

In this chapter we briefly discussed the key ideas of decision support systems, followed by a brief
introduction to Dempster-Shafer theory. We then introduced Subjective Logic and presented a brief
overview of the Haskell programming language. In the next chapter we will present our
research motivation, our thesis hypothesis, our research objectives, and our methodology.




\end{document}
