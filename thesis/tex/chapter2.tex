\documentclass[thesis.tex]{subfiles}

\begin{document}

\chapter{Background Information}
\label{chap:background-information}

In this chapter we will give a brief introduction to the relevant background material pertaining
to this thesis. We will begin with a discussion of \emph{decision support systems}, followed by
an overview of \emph{artificial reasoning}. Next we will discuss \emph{Dempster-Shafer Theory}, and
how certain flaws have lead to the development of \emph{Subjective Logic}. We will then conclude with
a brief overview of the \emph{Haskell} programming language.



\section{Decision Support Systems}

Decision support systems are information systems that are designed to aide users with various
decision-making tasks \cite{sprague1980framework}. Examples of such tasks are those pertaining to management,
planning, or operations. Typically decision support systems work with the kinds of unstructured
or underspecified problems faced by managers and decision-makers in many areas; involve the
synthesis of models, analytics, and data; are targetted at non-technical people; and are designed
to be flexible and adaptable in the face of new data or changes to the working environment
\cite{sprague1980framework}. Some example decision support systems are the UDMDSS system
for health research surveys \cite{kent2010application},
and the Gate Assignment Display System (GADS) developed for United Airlines
by Texas Instruments [cite].

In his 2002 book, \emph{Decision support systems: concepts and resources for managers}
\cite{power2002decision}, Daniel J Power breaks down Decision support systems into the following
taxonomy:

\begin{itemize}
  \item Communication-driven systems: systems that allow for more than one person to work on a shared task.
  \item Document-driven systems: systems that allow for the storage, retrieval and manipulation of unstructured data documents.
  \item Data-driven systems: systems that facilitate the manipulation of internal company data.
  \item Model-driven systems: systems that allow for access and modification of various models: whether they are financial, simulation, statistical, or other.
  \item Knowledge-driven systems: systems that contain problem solving expertise for the task at hand, typically encoded as facts and rules.
\end{itemize}

It is in the latter, \emph{knowledge-driven systems}, that this thesis is mostly concerned with: systems
that are required to reason with (possibly incomplete) domain knowledge in order to assist the human
decision-maker with his or her task.





\section{Artificial Reasoning}






\section{The Dempster Shafer Theory of Evidence}











\section{Subjective Logic}

\subsection{Introduction}

Subjective Logic is a newly emergent probabilistic logic calculus that supports reasoning
under uncertainty \cite{josang2001logic}.

The central object of Subjective Logic is the \emph{Subjective Opinion}, which is represented
as a tuple:

$$
\omega_X = \langle b_X, u_X, a_X \rangle
$$

where $X$ is a frame of discernment. $b_X$ is a vector of belief mass. Each element of $X$ is
assigned (possibly zero) mass. $u_X$ is a scalar representing the amount of uncertainty.
Lastly $a_X$ is a vector of a-priori belief mass, assigned to the elements of $X$. Each component
of $b_X$ and $a_X$ must be between 0 and 1, and while $a_X$ is additive ($\sum_{x \in X} a_X(x) = 1$),
$b_X$ is allowed to be sub-additive, where $u_X = 1 - \sum_{x \in X} b_X(x)$.
Opinions can either be \emph{uncertain}, where $u_X > 0$, or \emph{dogmatic}, when $u_X = 0$.

In the following sections we will describe the three kinds of opinions in Subjective Logic, starting
with the most simple objects: binomial opinions.



\subsection{Binomial Opinions}

\subsection{Multinomial Opinions}

\subsection{Hyper Opinions}

\subsection{Operators}





% Make this quick.

\section{Functional Programming in Haskell}

\subsection{Introduction}

\emph{Haskell} is a strongly typed, non-strict, pure functional
programming language \cite{hudak1992report} which was initially
developed to be a common language for researchers interested in
non-strict, pure functional programming languages
\cite{hudak2007history}.
By \emph{non-strict}, we mean that Haskell
evaluates expressions in a \emph{call-by-need} manner: expressions are
only evaluated if and when they are required [cite]. Haskell is a
\emph{functional programming language}, where the meaning of
\emph{functional} is the style of programs as described by John Backus
in his Turing award lecture: \emph{Can Programming Be Liberated from
  the von Neumann Style?}\cite{backus1978can}.  Lastly, Haskell is
\emph{pure} in the sense that all functions are functions in the
mathematical sense: they depend only on their inputs to produce their
outputs. Haskell does not support the use of global variables when
writing programs.

In this section we will briefly describe the syntax of Haskell in
order to give the reader enough familiarity to understand the code
listings of chapter \ref{chap:sl-in-haskell}. This section is by no
means exhaustive in its treatment of Haskell. For readers who wish to
learn Haskell in more depth, we suggest the book \emph{Real World
  Haskell}.



\subsection{Functions}

Functions in Haskell are written simply as equations:

\begin{spec}
increment n = n + 1
\end{spec}

The left hand side of the equation denotes the name of the function as well as the names of the
functions formal parameters. Multiple parameters are separated by white space. For example:

\begin{spec}
plus m n = m + n
\end{spec}

Function application again uses white space. For example, to call the function \emph{plus} as we have
defined it above, one would write

\begin{spec}
plus 4 5
\end{spec}

Functions in Haskell take their arguments one at a time, which allows for them to be \emph{curried}, or
partially applied. For example, the function \emph{increment} that we introduced previously can in fact
be written more simply in terms of our function \emph{plus} like so:

\begin{spec}
increment = plus 1
\end{spec}

Since Haskell supports basic arithmetic operators, we can in fact rewrite the above two functions as

\begin{spec}
plus = (+)
increment = (+ 1)
\end{spec}

All binary operators in Haskell can be converted into regular functions by surrounding them in brackets,
and the definition of \emph{increment} above is an example of a \emph{slice}. Inversely, any binary function
can be used as an infix operator by surrounding the function name in back-quotes. For example, it is
common to see the Haskell function \emph{elem}, which returns TRUE if an element is contained in a list, and
FALSE otherwise, used as an infix operator. The following program

\begin{spec}
3 `elem` [1, 2, 3, 4, 5]
\end{spec}

will return the result TRUE.

\subsection{Lists}


\subsection{Types}

\subsection{Type Classes}

\subsection{Functors}

\subsection{Applicative Functors}

\subsection{Monads}

\subsection{Combinators}











\end{document}
