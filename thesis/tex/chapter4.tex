\documentclass[thesis.tex]{subfiles}

\begin{document}


\chapter{SLHS: Subjective Logic in Haskell}
\label{chap:sl-in-haskell}


%\section{Overview}

In this chapter we introduce the library \emph{SLHS:
  Subjective Logic in Haskell}. SLHS is a library
for constructing and evaluating expressions of Subjective Logic. It
can be embedded into any existing Haskell project, and, through
Haskell's \emph{Foreign Function Interface}, can be utilized by other
programming languages, most notably $C$ and $C++$.

SLHS is designed to be simple to use: all Subjective Logic operators
take in Subjective Logic expressions as input, and return Subjective Logic expressions as output,
where Subjective Logic expressions are represented as functions that map some data
(frames of discernment, belief mass assignments, configuration information) to
some value - typically an opinion. Therefore the operators are \emph{higher order functions}.
It will be shown that these Subjective Logic expressions, or \emph{SLExpr}s are a
kind of \emph{monad}, and therefore when working with \emph{SLExpr}s one may leverage
Haskell's excellent support for monadic programming. We use the monad operators provided by Haskell liberally
within the implementation of SLHS, and we utilize Haskell's \emph{do-notation} - a syntactic sugar available
when writing monadic programs - to keep the code concise and easy to read.


\section{Core Components}

In this section we will introduce components that form the nucleus of the library. These include the implementation details
for objects such as the \emph{frame of discernment}, \emph{belief vectors}, as well as the the \emph{SLExpr} type.
The Subjective Logic operators are implemented as functions that take and return objects of type SLExpr, and the
monadic interface of SLExpr controls how the expressions are combined.

\subfile{./SLHS/Vector.lhs}
\subfile{./SLHS/Frame.lhs}
\subfile{./SLHS/Types.lhs}

\subfile{./SLHS/Opinions.lhs}
\subfile{./SLHS/Operators.lhs}
\subfile{./SLHS/Extensions.lhs}




\section{Limitations}
\label{sec:limitations}

While SLHS is a robust implementation of the opinions and operators of Subjective Logic,
our decision to represent all numbers as arbitrary-precision rational numbers imposes a
fundamental restriction on the kinds of data that the library can handle. Any computation
that involves the assignment of irrational numbers as belief masses cannot be represented
directly in our system. However, it is possible to modify SLHS to be able to handle such
values: one simply needs to either change the belief vectors to use values of type
\emph{Double} instead of \emph{Rational}, or better yet, represent the numeric type as
an additional type parameter to the belief vector. The latter would allow the user to
use any numerical type of his or her choosing.




%
% Under extensions of SL, mention how SL is incomplete as far as total operators. Operators
% seemingly added to fill some need... Perhaps discuss some information theory/entropy here...
%



\section{Summary}

In this chapter we introduced SLHS: Subjective Logic in Haskell, a library
for representing and evaluating Subjective Logic expressions. We discussed the core
components of the library including the monads that represent the expressions, the
battery of Subjective Logic opinions and operators, and we concluded with a new operator
that is unique to the library.

We have done our best to ensure that the operators implemented in SLHS mirror the definitions
found in the literature; however any errors that may arise are the sole responsibility of the author.
As is true for many complex software components, it is expected that errors and deficiencies will
be found by the users of SLHS. As the famous computer scientist C.A.R. Hoare said during his 1980 Turing Award lecture \cite{hoare19811980}:

\begin{quote}
There are two ways of constructing a software design: One way is to make it so simple that there are
obviously no deficiencies, and the other way is to make it so complicated that there are no obvious
deficiencies. The first method is far more difficult.
\end{quote}

In the next chapter we present a termination
analysis of the library, analyze the complexity of a representative subset of the operators, discuss
how we leveraged the strong type system to catch errors at compile time, discuss the role that monads have played in the design of the library,
demonstrate the expressive power of the library through example programs, and discuss how SLHS fits within the larger UDMDSS system.








\end{document}
